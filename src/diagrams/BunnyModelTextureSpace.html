<:Window on:resize="resize()"/>

<figure>
  
  <div class="inputs">
    <h4>Input Controls</h4>
    <figcaption>
      <p>
        A naïve approach optimizes the texture as an image with a feature visualization objective function.
      </p>
      <p>
        Because this optimization is not aware of the UV mapping used to render the object, it creates artifacts such as 
        <a class="{{index==1 ? 'selected' : ''}}" on:click='toggle(1)'>seams</a>
        , 
        <a class="{{index==2 ? 'selected' : ''}}" on:click='toggle(2)'>badly oriented patterns</a>
         and 
        <a class="{{index==3 ? 'selected' : ''}}" on:click='toggle(3)'>low resolution areas</a>.
      </p>
      <ToggleSwitch bind:checked='unfoldFlag' text="unfold texture"></ToggleSwitch> 
    </figcaption>
  </div>


  <div ref:outputExample class="output-naive">
    <h4>Naïve Optimization</h4>
    {{#await resourcePromise}}
      <p>Loading the 3D model...</p>
    {{then resources}}
      <THREEjsGuidedView ref:view resources={{resources}} textureUrl={{naiveTextureUrl}} :width :height :backgroundColor camId={{index}} bind:unfoldFlag></THREEjsGuidedView>
    {{catch error}}
      <p>A problem occurred while loading the 3D model!</p>
    {{/await}}
  </div>
  
  <div class="output-rendered">
    <h4>Render-based Optimization</h4>
    {{#await resourcePromise}}
      <p>Loading the 3D model...</p>
    {{then resources}}
      <THREEjsGuidedView ref:view resources={{resources}} textureUrl={{renderedTextureUrl}} :width :height :backgroundColor camId={{index}} bind:unfoldFlag></THREEjsGuidedView>
    {{catch error}}
      <p>A problem occurred while loading the 3D model!</p>
    {{/await}}
  </div>

</figure>

<style>

figure {
  grid-column: page;
  display: grid;
  grid-gap: inherit;
  grid-row-gap: 10px;
  grid-auto-flow: column;
  grid-template: 
    "input" auto
    "naive" auto
    "rendered" auto / 1fr;
}

figure > * {
  overflow: hidden;
}

.inputs {
  grid-area: input;
}

.output-naive {
  grid-area: naive;
}

.output-rendered {
  grid-area: rendered;
}

figure > div {
  display: grid;
  grid-gap: inherit;
  align-items: flex-start;
  grid-auto-rows: min-content;
  grid-auto-flow: row;
}

h4 {
  border-bottom: 1px solid rgba(0, 0, 0, 0.1);
  padding-bottom: 8px;
  margin: 0;
  font-weight: 700;
}

a {
  cursor: pointer;
}

a.selected {
  color: hsl(24, 100%, 50%);
  border-bottom: 1px solid hsl(24, 100%, 50%);
  text-shadow: 0.5px 0 0 hsl(24, 100%, 50%);
} 

@media (min-width: 768px) {
  figure {
    grid-template: 
      "naive rendered" auto
      "input input" auto / 1fr 1fr;
  }
}

@media (min-width: 1180px) {
  figure {
    grid-template: 
      "input naive rendered" auto / 1fr 2fr 2fr;
  }
}

</style>

<script>
import ToggleSwitch from '../components/ToggleSwitch';
import THREEjsGuidedView from '../components/THREEjsGuidedView';
import Sprite from '../components/Sprite.html';
import { range } from '../util';

export default {
  components: { THREEjsGuidedView, Sprite, ToggleSwitch },
  oncreate() {
  },
  data() {
    return {
      model_folder: 'models/bunny',
      faces_file: 'face.3d',
      positions_file: 'position.3d',
      uvs_file: 'uv.3d',
      sprite_class: 'selection_sprite',
      naiveTextureUrl: 'models/bunny/3Dfeatureviz/texture_space.jpg',
      renderedTextureUrl: 'models/bunny/3Dfeatureviz/texture_0.jpg',
      resourcesReady: false,
      backgroundColor: '#f7f7f7',
      width: 400,
      height: 400,
      index: 0,
      unfoldFlag: false,
    }
  },
  computed: {
    resources: (model_folder, faces_file, positions_file, uvs_file) => {
      return new Map([
        ['positions', [model_folder + '/' + positions_file, Float32Array]],
        ['uvs', [model_folder + '/' + uvs_file, Float32Array]],
        ['faces', [model_folder + '/' + faces_file, Uint16Array]],
      ]);
    },
    resourcePromise: (resources) => {
      return Promise.all([...resources].map(([resource, [path, DType]]) => {
        return fetch(path).then((response) => {
          return response.arrayBuffer();
        }).then((arrayBuffer) => {
          return new DType(arrayBuffer);
        });
      }));
    }
  },
  methods: {
    toggle: function (toggledIndex) {
      const currentIndex = this.get('index');
      if (toggledIndex == currentIndex) {
        this.set({index: 0});
      } else {
        this.set({index: toggledIndex});
      }
    },
    resize: function() {
      const bb = this.refs.outputExample.getBoundingClientRect();
      this.set({width: bb.width });
    }
  },
  helpers: {range}
}
</script>
