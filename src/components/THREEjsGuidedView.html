<div class='meshview'>
  <div ref:container class='container'
       style='--width:{{width}}px;--height:{{height}}px;'
       >
  </div>
  <div class='controls'>
    <input ref:unfoldBox id="unfoldBox" type="checkbox" class="control" bind:checked='unfoldFlag'/>
    <label for="unfoldBox">Unfold</label>
    <input ref:cameraPosId id ="cameraPosId" type="number" class="control" value="0" min="0" max="2">

  </div>
</div>

<style>
  .container {
    width:  var(--width);
    height: var(--height);
    /*border: 1px solid #ddd;*/
    margin-left: auto;
    margin-right: auto;
  }
</style>

<script>
import OrbitControls from 'three-orbitcontrols';
import { Scene, PerspectiveCamera, BufferGeometry, BufferAttribute, TextureLoader, ShaderMaterial, DoubleSide, Mesh, Color, WebGLRenderer, Vector3, Vertex, MeshBasicMaterial, Geometry, Face3, PlaneGeometry, Camera, Quaternion } from 'three';

const vertexShaderString = `
  uniform float viewAspect;
  uniform float unfolding_perc;
  uniform float shadeFlag;
  varying vec2 text_coord;
  varying float shading;

  void main () {
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    vec4 plane_position = vec4((uv.x*2.0-1.0)/viewAspect, (uv.y*2.0-1.0), 0, 1);
    gl_Position = mix(gl_Position, plane_position, unfolding_perc);
    //not normalized on purpose to simulate the rotation
    shading = 1.0;
    if (shadeFlag > 0.5) {
      vec3 light_vector = mix(normalize(cameraPosition-position), normal, unfolding_perc);
      shading = dot(normal, light_vector);
    }
    text_coord = uv;
  }
`;
const fragmentShaderString = `
  uniform float unfolding_perc;
  varying vec2  text_coord;
  varying float shading;
  uniform sampler2D texture;

  void main() {
    gl_FragColor = texture2D(texture, text_coord);
    gl_FragColor.rgb *= (shading/2.0) + 0.5;
  }
`;

const vertexShaderTextureString = `
  void main () {
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;
const fragmentShaderTextureString = `
  uniform float fade_in_perc;
  uniform float width;
  uniform float height;
  uniform sampler2D texture;
  uniform vec3 background_color;

  //a bit cluncky
  void main() {
    vec2 uv;
    if(width/height > 1.){
      uv.x = (gl_FragCoord.x-(width-height)/2.)/height;
      uv.y = gl_FragCoord.y/height;
      if(uv.x > 1. || uv.x < 0.){
        gl_FragColor = vec4(background_color,1);
        return;
      }
    }else{
      uv.x = gl_FragCoord.x/width;
      uv.y = (gl_FragCoord.y-(height-width)/2.)/width;
      if(uv.y > 1. || uv.y < 0.){
        gl_FragColor = vec4(background_color,1);
        return;
      }
    }
    gl_FragColor = mix(vec4(background_color,1.),texture2D(texture, uv),fade_in_perc);
  }
`;

export default {
  oncreate() {
    const { texture_url, backgroundColor, resources, width, height } = this.get();
    const [positions, uvs, faces] = resources;
    const unfoldBox = this.refs.unfoldBox;
    const shadeBox = this.refs.shadeBox;
    const container = this.refs.container;
    const cameraPosId = this.refs.cameraPosId;
    const component = this;

    const unfoldDuration  = 1500.0;
    const preFadeDuration = 200.0;
    const fadeInDuration  = 500.0;
    const cameraMoveTime = 350;

    var camera, scene, renderer, controls, material;
    var sceneTexture, cameraTexture, materialTexture;

    var unfolded = false;
    var animationStart = -unfoldDuration*10.0;
    var cameraAnimationStart = -cameraMoveTime *10.;
    var initCameraLocation;
    var camId = 0;

    init();
    animate(0.0);

    var cameraPositions;

    function init() {
      //scene contain the 3D model
      scene = new Scene();
      camera = new PerspectiveCamera(42, width / height, 0.1, 100);
      camera.position.z = 2.0;
      scene.add(camera);

      var geometry = new BufferGeometry();
      geometry.addAttribute( 'position', new BufferAttribute(positions, 3 ) );
      geometry.addAttribute( 'uv', new BufferAttribute(uvs, 2) );
      geometry.setIndex(new BufferAttribute(faces, 1 ));
      geometry.computeVertexNormals();
      var texture = new TextureLoader().load(texture_url, update);
      material = new ShaderMaterial( {
        uniforms: {
          viewAspect: {value: width/height},
          unfolding_perc: { value: 0.0 },
          shadeFlag: { value: 1.0 },
          texture: { type: 't', value: texture },
        },
        side: DoubleSide,
        vertexShader: vertexShaderString,
        fragmentShader: fragmentShaderString
      });
      component.set({material: material});
      var mesh = new Mesh(geometry, material);
      scene.add(mesh);

      //SceneTexture draws the background texture
      sceneTexture = new Scene();
      materialTexture = new ShaderMaterial( {
        uniforms: {
          width: {value: width},
          height: {value: height},
          fade_in_perc: { value: 0.0 },
          texture: { type: 't', value: texture },
          background_color: { value: new Color( backgroundColor )}
        },
        vertexShader: vertexShaderTextureString,
        fragmentShader: fragmentShaderTextureString
      });
      var backgroundTexture = new Mesh(
        new PlaneGeometry(2, 2, 0),
        materialTexture
      );
      cameraTexture = new Camera();
      sceneTexture.add(cameraTexture);
      sceneTexture.add(backgroundTexture);

      //Renderer initialization
      renderer = new WebGLRenderer({antialias: true});
      renderer.setPixelRatio(window.devicePixelRatio ? window.devicePixelRatio : 1);
      renderer.setSize(width, height);
      container.appendChild(renderer.domElement);
      controls = new OrbitControls( camera, renderer.domElement );
      controls.enablePan = true;
      controls.enableZoom = true;

      // to pass
      cameraPositions = [
          //new Vector3(-0.658,0.297,-0.246),
          new Vector3(-0.072,-0.354,0.627),
          new Vector3(-1.20,-0.105,0.062),
          new Vector3(0.614533221221188, -0.20237065729928297, 0.8685499623393961)
        ];
      initCameraLocation = new Vector3(0,0,0);

      //Disable the autoClear option to draw the two scenes together
      renderer.autoClear = false;
      //render on change only
      controls.addEventListener('change', function() {
        // fold mesh back if the user interacts with the model
        unfoldBox.checked = false;
        update();
      });
      document.querySelectorAll('.control').forEach(e=>{
        e.addEventListener('change', update);
      });
      document.querySelectorAll('.control').forEach(e=>{
        e.addEventListener('change', update);
      });
    }

    function update() {
      requestAnimationFrame(animate);
    }

    function ease(x) {
      x = Math.min(Math.max(x, 0.0), 1.0);
      return x*x*(3.0 - 2.0*x);
    }

    function animate(time){
      if(cameraPosId.value != camId){
        camId = cameraPosId.value;
        initCameraLocation.copy(camera.position);
        cameraAnimationStart = time;
        update();
      }
      if(time - cameraAnimationStart < cameraMoveTime){
        //Forced camera movement
        var interpFactor = ease((time - cameraAnimationStart)/cameraMoveTime);
        //var tempVector = new Vector3(initCameraLocation);
        //tempVector.lerp(initCameraLocation,cameraPositions[camId],interpFactor);
        //tempVector.lerp(cameraPositions[camId],interpFactor);
        var x = initCameraLocation.x * (1-interpFactor) + cameraPositions[camId].x*interpFactor;
        var y = initCameraLocation.y * (1-interpFactor) + cameraPositions[camId].y*interpFactor;
        var z = initCameraLocation.z * (1-interpFactor) + cameraPositions[camId].z*interpFactor;

        //camera.position.set(tempVector.x,tempVector.y,tempVector.z);
        camera.position.set(x,y,z);
        update();
      }

      var unfoldFlag = unfoldBox.checked;
      if (unfolded != unfoldFlag) {
        unfolded = unfoldFlag;
        animationStart = time - Math.max(animationStart+unfoldDuration+preFadeDuration+fadeInDuration-time, 0.0);
      }
      var animationTime = (time-animationStart) / (unfoldDuration+preFadeDuration+fadeInDuration);
      var unfoldTime = (time-animationStart-(unfolded?0:fadeInDuration+preFadeDuration)) / unfoldDuration;
      var fadeInTime = (time-animationStart-(unfolded?unfoldDuration+preFadeDuration:0)) / fadeInDuration;
      if (animationTime < 1.0) {
        //update();
      }
      //3D model
      var unfoldVal = ease(unfoldTime);
      unfoldVal = unfolded ? unfoldVal : 1.0 - unfoldVal;
      material.uniforms.unfolding_perc.value = unfoldVal;
      material.uniforms.shadeFlag.value = 1.0;

      //Background texture
      var fadeIndVal = ease(fadeInTime);
      fadeIndVal = unfolded ? fadeIndVal : 1.0 - fadeIndVal;
      materialTexture.uniforms.fade_in_perc.value = fadeIndVal;

      //Camera controls
      controls.update();

      //Render the two scenes
      renderer.clear();
      renderer.render(sceneTexture, cameraTexture);
      renderer.clearDepth();
      renderer.render(scene, camera);
    }

    this.observe('texture_url', texture_url => {
      //A new texture is loaded
      const { material } = this.get();
      console.debug(texture_url, material)
      const texture = new TextureLoader().load(texture_url, update);
      material.uniforms.texture = { type: 't', value: texture };
      materialTexture.uniforms.texture = { type: 't', value: texture };
    });
  },
  data() {
    return {
      texture_url: null,
      backgroundColor: '#ffffff',
      width: 400,
      height: 400,
      shadedFlag: true,
      unfoldFlag: false,
      unfoldDuration: 1000.0,
    }
  },
  computed: {

  },
  methods: {

  }
}
</script>
