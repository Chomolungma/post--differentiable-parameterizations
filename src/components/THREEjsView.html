<div ref:container class='container' 
  style='--width:{{width}}px;--height:{{height}}px;'>
</div>


<style>
  .container {
    width:  var(--width);
    height: var(--height);
    /*border: 1px solid #ddd;*/
    margin-left: auto;
    margin-right: auto;
    cursor: all-scroll;
  }
</style>


<script>
import OrbitControls from 'three-orbitcontrols';
import { Scene, PerspectiveCamera, BufferGeometry, BufferAttribute, 
  TextureLoader, ShaderMaterial, DoubleSide, Mesh, Color, WebGLRenderer, 
  Vector3, Vertex, MeshBasicMaterial, Geometry, Face3, PlaneGeometry, 
  Camera, Quaternion } from 'three';

const vertexShaderString = `
  uniform float viewAspect;
  uniform float unfolding_perc;
  uniform float shadeFlag;
  varying vec2 text_coord;
  varying float shading;

  void main () {
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    vec4 plane_position = vec4((uv.x*2.0-1.0)/viewAspect, (uv.y*2.0-1.0), 0, 1);
    gl_Position = mix(gl_Position, plane_position, unfolding_perc);
    //not normalized on purpose to simulate the rotation
    shading = 1.0;
    if (shadeFlag > 0.5) {
      vec3 light_vector = mix(normalize(cameraPosition-position), normal, unfolding_perc);
      shading = dot(normal, light_vector);
    }
    text_coord = uv;
  }
`;
const fragmentShaderString = `
  uniform float unfolding_perc;
  varying vec2  text_coord;
  varying float shading;
  uniform sampler2D texture;

  void main() {
    gl_FragColor = texture2D(texture, text_coord);
    gl_FragColor.rgb *= (shading/2.0) + 0.5;
  }
`;

const vertexShaderTextureString = `
  void main () {
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;
const fragmentShaderTextureString = `
  uniform float fade_in_perc;
  uniform float width;
  uniform float height;
  uniform sampler2D texture;
  uniform vec3 background_color;

  //a bit cluncky
  void main() {
    vec2 uv;
    if(width/height > 1.){
      uv.x = (gl_FragCoord.x-(width-height)/2.)/height;
      uv.y = gl_FragCoord.y/height;
      if(uv.x > 1. || uv.x < 0.){
        gl_FragColor = vec4(background_color,1);
        return;
      }
    } else {
      uv.x = gl_FragCoord.x/width;
      uv.y = (gl_FragCoord.y-(height-width)/2.)/width;
      if(uv.y > 1. || uv.y < 0.){
        gl_FragColor = vec4(background_color,1);
        return;
      }
    }
    gl_FragColor = mix(vec4(background_color,1.),texture2D(texture, uv),fade_in_perc);
  }
`;

export default {
  components: {
    ToggleSwitch
  },
  oncreate() {
    const self = this;
    const { textureUrl, backgroundColor, resources, width, height, enableZoom, autoRotate } = this.get();
    const [positions, uvs, faces] = resources;
    const shadeBox = this.refs.shadeBox;
    const container = this.refs.container;
    const component = this;

    const unfoldDuration  = 1500.0;
    const preFadeDuration = 200.0;
    const fadeInDuration  = 500.0;
    var camera, scene, renderer, controls, material;
    var sceneTexture, cameraTexture, materialTexture;

    var unfolded = false;
    var animationStart = -unfoldDuration*10.0;

    init();
    animate(0.0);

    function init() {
      //scene contain the 3D model
      scene = new Scene();
      camera = new PerspectiveCamera(42, width / height, 0.1, 100);
      camera.position.z = 2.5;
      scene.add(camera);

      var geometry = new BufferGeometry();
      geometry.addAttribute( 'position', new BufferAttribute(positions, 3 ) );
      geometry.addAttribute( 'uv', new BufferAttribute(uvs, 2) );
      geometry.setIndex(new BufferAttribute(faces, 1 ));
      geometry.computeVertexNormals();
      var texture = new TextureLoader().load(textureUrl, update);
      material = new ShaderMaterial( {
        uniforms: {
          viewAspect: {value: width/height},
          unfolding_perc: { value: 0.0 },
          shadeFlag: { value: 1.0 },
          texture: { type: 't', value: texture },
        },
        side: DoubleSide,
        vertexShader: vertexShaderString,
        fragmentShader: fragmentShaderString
      });
      component.set({material: material});
      var mesh = new Mesh(geometry, material);
      mesh.name = 'bunny';
      scene.add(mesh);

      //SceneTexture draws the background texture
      sceneTexture = new Scene();
      materialTexture = new ShaderMaterial( {
        uniforms: {
          width: {value: width},
          height: {value: height},
          fade_in_perc: { value: 0.0 },
          texture: { type: 't', value: texture },
          background_color: { value: new Color( backgroundColor )}
        },
        vertexShader: vertexShaderTextureString,
        fragmentShader: fragmentShaderTextureString
      });
      var backgroundTexture = new Mesh(
        new PlaneGeometry(2, 2, 0),
        materialTexture
      );
      cameraTexture = new Camera();
      sceneTexture.add(cameraTexture);
      sceneTexture.add(backgroundTexture);

      //Renderer initialization
      renderer = new WebGLRenderer({antialias: true});
      renderer.setPixelRatio(window.devicePixelRatio ? window.devicePixelRatio : 1);
      renderer.setSize(width, height);
      container.appendChild(renderer.domElement);
      controls = new OrbitControls( camera, renderer.domElement );
      controls.enablePan = false;
      controls.enableZoom = enableZoom;
      controls.autoRotateSpeed = 0.25;
      controls.autoRotate = autoRotate;
      controls.minDistance = 0.5;
      controls.maxDistance = 4;
      //Disable the autoClear option to draw the two scenes together
      renderer.autoClear = false;
      //render on change only
      controls.addEventListener('change', function() {
        // fold mesh back if the user interacts with the model
        self.set({unfoldFlag: false});
        update();
      });
      controls.addEventListener('start', function(){
        controls.autoRotate = false;
      });
      document.querySelectorAll('.control').forEach(e=>{
        e.addEventListener('change', update);
      });
    }

    function update() {
      requestAnimationFrame(animate);
    }

    function ease(x) {
      x = Math.min(Math.max(x, 0.0), 1.0);
      return x*x*(3.0 - 2.0*x);
    }

    function animate(time) {
      const unfoldFlag = self.get('unfoldFlag');
      if (unfolded != unfoldFlag) {
        unfolded = unfoldFlag;
        animationStart = time - Math.max(animationStart+unfoldDuration+preFadeDuration+fadeInDuration-time, 0.0);
      }
      var animationTime = (time-animationStart) / (unfoldDuration+preFadeDuration+fadeInDuration);
      var unfoldTime = (time-animationStart-(unfolded?0:fadeInDuration+preFadeDuration)) / unfoldDuration;
      var fadeInTime = (time-animationStart-(unfolded?unfoldDuration+preFadeDuration:0)) / fadeInDuration;
      if (animationTime < 1.0) {
        update();
      }
      //3D model
      var unfoldVal = ease(unfoldTime);
      unfoldVal = unfolded ? unfoldVal : 1.0 - unfoldVal;
      material.uniforms.unfolding_perc.value = unfoldVal;
      material.uniforms.shadeFlag.value = 1.0;

      //Background texture
      var fadeIndVal = ease(fadeInTime);
      fadeIndVal = unfolded ? fadeIndVal : 1.0 - fadeIndVal;
      materialTexture.uniforms.fade_in_perc.value = fadeIndVal;

      //Camera controls
      // controls.update();

      //Render the two scenes
      renderer.clear();
      renderer.render(sceneTexture, cameraTexture);
      renderer.clearDepth();
      renderer.render(scene, camera);
    }

    this.observe('textureUrl', textureUrl => {
      //A new texture is loaded
      const { material } = this.get();
      const texture = new TextureLoader().load(textureUrl, update);
      material.uniforms.texture = { type: 't', value: texture };
      materialTexture.uniforms.texture = { type: 't', value: texture };
    });
    
    this.observe('unfoldFlag', unfoldFlag => {
      controls.autoRotate = false;
      update();
    });
    
    this.observe('autoRotate', autoRotate => {
      controls.autoRotate = autoRotate;
    });
    
    this.observe('width', width => {
      materialTexture.uniforms.width.value = width;
      material.uniforms.viewAspect.value = width / height;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      update();
    });
  },
  data() {
    return {
      textureUrl: null,
      backgroundColor: '#f7f7f7',
      width: 400,
      height: 400,
      shadedFlag: true,
      unfoldFlag: false,
      unfoldDuration: 1000.0,
      enableZoom: true,
      autoRotate: true
    }
  },
  computed: {

  },
  methods: {

  }
}
</script>
