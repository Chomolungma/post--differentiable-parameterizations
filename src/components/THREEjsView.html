<div class='meshview'>
  <div ref:container class='container'
       style='--width:{{width}}px;--height:{{height}}px;'
       >
  </div>
  <div class='controls'>
    <input ref:unfoldBox id="unfoldBox" type="checkbox" class="control" bind:checked='unfoldFlag'/>
    <label for="unfoldBox">Unfold</label>
  </div>
</div>

<style>
  .container {
    width:  var(--width);
    height: var(--height);
    /*border: 1px solid #ddd;*/
    margin-left: auto;
    margin-right: auto;
  }
</style>

<script>
import OrbitControls from 'three-orbitcontrols';
import { Scene, PerspectiveCamera, BufferGeometry, BufferAttribute, TextureLoader, ShaderMaterial, DoubleSide, Mesh, Color, WebGLRenderer } from 'three';

const vertexShaderString = `
  uniform float viewAspect;
  uniform float unfolding_perc;
  uniform float shadeFlag;
  varying vec2 text_coord;
  varying float shading;

  void main () {
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    vec4 plane_position = vec4((uv.x*2.0-1.0)/viewAspect, (uv.y*2.0-1.0), 0, 1);
    gl_Position = mix(gl_Position, plane_position, unfolding_perc);
    //not normalized on purpose to simulate the rotation
    shading = 1.0;
    if (shadeFlag > 0.5) {
      vec3 light_vector = mix(normalize(cameraPosition-position), normal, unfolding_perc);
      shading = dot(normal, light_vector);
    }
    text_coord = uv;
  }
`;

const fragmentShaderString = `
  uniform float unfolding_perc;
  varying vec2  text_coord;
  varying float shading;
  uniform sampler2D texture;

  void main() {
    gl_FragColor = texture2D(texture, text_coord);
    gl_FragColor.rgb *= (shading/2.0) + 0.5;
  }
`;

export default {
  oncreate() {
    const { texture_url, backgroundColor, resources, width, height } = this.get();
    const [positions, uvs, faces] = resources;
    const unfoldBox = this.refs.unfoldBox;
    const shadeBox = this.refs.shadeBox;
    const container = this.refs.container;
    const component = this;

    const unfoldDuration = 1000.0;
    var camera, scene, renderer, controls, material;
    var unfolded = false;
    var unfoldStart = -unfoldDuration*10.0;

    init();
    animate(0.0);

    function init() {
      scene = new Scene();
      camera = new PerspectiveCamera(50, width / height, 0.1, 100);
      camera.position.z = 2.0;
      scene.add(camera);
      var geometry = new BufferGeometry();
      geometry.addAttribute( 'position', new BufferAttribute(positions, 3 ) );
      geometry.addAttribute( 'uv', new BufferAttribute(uvs, 2) );
      geometry.setIndex(new BufferAttribute(faces, 1 ));
      geometry.computeVertexNormals();
      var texture = new TextureLoader().load(texture_url, update);
      material = new ShaderMaterial( {
        uniforms: {
          viewAspect: {value: width/height},
          unfolding_perc: { value: 0.0 },
          shadeFlag: { value: 1.0 },
          texture: { type: 't', value: texture },
        },
        side: DoubleSide,
        vertexShader: vertexShaderString,
        fragmentShader: fragmentShaderString
      });
      component.set({material: material});
      var mesh = new Mesh(geometry, material);
      scene.add(mesh);
      scene.background = new Color( backgroundColor );
      renderer = new WebGLRenderer({antialias: true});
      renderer.setPixelRatio(window.devicePixelRatio ? window.devicePixelRatio : 1);
      renderer.setSize(width, height);
      container.appendChild(renderer.domElement);
      controls = new OrbitControls( camera, renderer.domElement );
      // render on change only
      controls.addEventListener('change', function() {
        // fold mesh back if user wants to interact
        unfoldBox.checked = false;
        update();
      });
      document.querySelectorAll('.control').forEach(e=>{
        e.addEventListener('change', update);
      });
    }

    function update() {
      requestAnimationFrame(animate);
    }

    function ease(x) {
      x = Math.min(Math.max(x, 0.0), 1.0);
      return x*x*(3.0 - 2.0*x);
    }

    function animate(time) {
      var unfoldFlag = unfoldBox.checked;
      if (unfolded != unfoldFlag) {
        unfolded = unfoldFlag;
        unfoldStart = time - Math.max(unfoldStart+unfoldDuration-time, 0.0);
      }
      var unfoldTime = (time-unfoldStart) / unfoldDuration;
      if (unfoldTime < 1.0) {
        update();
      }
      var unfoldVal = ease(unfoldTime);
      unfoldVal = unfolded ? unfoldVal : 1.0 - unfoldVal;
      material.uniforms.unfolding_perc.value = unfoldVal;
      material.uniforms.shadeFlag.value = 1.0;
      controls.update();
      renderer.render(scene, camera);
    }

    this.observe('texture_url', texture_url => {
      const { material } = this.get();
      console.debug(texture_url, material)
      const texture = new TextureLoader().load(texture_url, update);
      material.uniforms.texture = { type: 't', value: texture };
    });
  },
  data() {
    return {
      texture_url: null,
      backgroundColor: '#ffffff',
      width: 400,
      height: 400,
      shadedFlag: true,
      unfoldFlag: false,
      unfoldDuration: 1000.0,
    }
  },
  computed: {

  },
  methods: {

  }
}
</script>
